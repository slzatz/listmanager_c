https://c-for-dummies.com/blog/?p=682

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define COLUMN 40

int main()
{
    char preamble[] = "We the People of the United States, in Order to form a more perfect Union, establish Justice, insure domestic Tranquility, provide for the common defense, promote the general Welfare, and secure the Blessings of Liberty to ourselves and our Posterity, do ordain and establish this Constitution for the United States of America.";
    char *base,*right_margin;
    int length,width;

    length = strlen(preamble);
    base = preamble;
    width = COLUMN;

    while(*base)
    {
        if(length <= width)
        {
            puts(base);     /* display string */
            return(0);      /* and leave */
        }
        right_margin = base+width;
        while(!isspace(*right_margin))
        {
            right_margin--;
            if( right_margin == base)
            {
                right_margin += width;
                while(!isspace(*right_margin))
                {
                    if( *right_margin == '\0')
                        break;
                    right_margin++;
                }
            }
        }
        *right_margin = '\0';
        puts(base);
        length -= right_margin-base+1;      /* +1 for the space */
        base = right_margin+1;
    }

    return(0);
}

//////////////////////////////////////////////////////////////////////////////////////////

https://stackoverflow.com/questions/22582989/word-wrap-program-c

inline int wordlen(const char * str){
   int tempindex=0;
   while(str[tempindex]!=' ' && str[tempindex]!=0 && str[tempindex]!='\n'){
      ++tempindex;
   }
   return(tempindex);
}
void wrap(char * s, const int wrapline){

   int index=0;
   int curlinelen = 0;
   while(s[index] != '\0'){

      if(s[index] == '\n'){
         curlinelen=0;
      }
      else if(s[index] == ' '){

         if(curlinelen+wordlen(&s[index+1]) >= wrapline){
            s[index] = '\n';
            curlinelen = 0;
         }

      }

      curlinelen++;
      index++;
   }

}

http://www.roguebasin.com/index.php?title=Line_wrapping_in_C
/*
  This code provides a minimal way to do line wrapping in C.
 
  strwrap() will take an input string and a desired line width and
  attempt to split it into suitable chunks.
 
  The result will be provided as an array of string pointers, each
  referring to the position of the first character on a line.
 
  It tries to be clever about whitespace and start each line at the
  beginning of a word (it will not erase whitespace in the middle of
  lines). Newlines encountered in the string will be converted into
  dummy lines of 0 width.
 
  How to use:
  - Prepare the text you wish to wrap
  - Call strwrap()
  - Print the result line by line
  - Free the arrays strwrap() returned
 
  The code was designed with the following restrictions:
  - the original string must remain unmodified
  - everything contained in a single function
  - no structs or declarations (also helps minimize cleanup)
 
  Realistic expectations: There is no support for wide characters. It
  has no notion of control codes or formatting markup and will treat
  these just like regular words. It doesn't really care about tabs. It
  doesn't do anything about line raggedness or hyphenation.
 
  This code is meant to be educational and hasn't been overly
  optimized. I could probably use char pointers instead of array
  offsets in many places. However, keeping it this way should make
  it easier to adapt for other languages.
 
  main() provides a small test program.
 
  Compile with something like: gcc strwrap.c -o strwraptest
 
  You may use this code in your program. Please don't distribute
  modified versions without clearly stating you have changed it.
 
  ulf.astrom@gmail.com / happyponyland.net, 2012-11-12
*/
 
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
 
 
/*
  Splits s into multiple lines of width w. Returns the number of
  lines. line_ret will be set to an array of string pointers, each
  pointing to the start of a line. len_ret will be set to an array of
  ints, describing how wide the corresponding line is. If an error
  occurs 0 is returned; line_ret and len_ret are then left unmodified.
*/
int strwrap(char * s, int w, char *** line_ret, int ** len_ret)
{
  int allocated; /* lines allocated */
  int lines; /* lines used */
  char ** line;
  int * len;
  int tl; /* total length of the string */
  int l; /* length of current line */
  int p; /* offset (from s) of current line */
  int close_word;
  int open_word;
  int i;
 
  if (s == NULL)
    return 0;
 
  tl = strlen(s);
 
  if (tl == 0 || w <= 0)
    return 0;
 
  lines = 0;
 
  /*
    Preemptively allocate memory. This should be enough for most uses;
    if we need more we will realloc later.
  */
  allocated = (tl / w) * 1.5 + 1;
 
  line = (char **) malloc(sizeof(char *) * allocated);
  len = (int *) malloc(sizeof(int) * allocated);
 
  if (line == NULL || len == NULL)
    return 0;
 
  /*
    p will be an offset from the start of the string and the start of
    the current line we are processing.
  */
 
  p = 0;
 
  while (p < tl)
  {
    /* Detect initial newlines */
    if (s[p] == '\n')
    {
      l = 0;
      goto make_new_line;
    }
 
    /*
      Fast-forward past initial whitespace on the current line. You
      might want to comment this out if you need formatting like
      "  * Bullet point lists" and wish to preserve the spaces.
    */
    if (isspace(s[p]))
    {
      p++;
      continue;
    }
 
    /*
      Decide how long the current line should be. We typically want
      the line to take up the full allowed line width, but we also
      want to limit the perceived length of the final line. If the
      line width overshoots the end of the string, truncate it.
    */
    if (p + w > tl)
      w = tl - p;
 
    l = w;
 
    /*
      If the break point ends up within a word, count how many
      characters of that word fall outside the window to the right.
    */
    close_word = 0;
 
    while (s[p + l + close_word] != '\0' && !isspace(s[p + l + close_word]))
      close_word++;
 
    /*
      Now backtrack from the break point until we find some
      whitespace. Keep track of how many characters we traverse.
    */
    open_word = 0;
 
    while (s[p + l] != '\0' && !isspace(s[p + l]))
    {
      l--;
      open_word ++;
 
      /*
	If the current word length is near the line width it will be
	hard to fit it all on a line, so we should just leave as much
	of it as possible on this line. Remove the fraction if you
	only want longer words to break.
      */
      if (open_word + close_word > w * 0.8)
      {
	l = w;
	break;
      }
    }
 
    /*
      We now have a line width we wish to use. Just make a final check
      there are no newlines in the middle of the line. If there are,
      break at that point instead.
    */
    for (i = 0; i < l; i++)
    {
      if (s[p + i] == '\n')
      {
	l = i;
	break;
      }
    }
 
  make_new_line:
    /*
      We have decided how long this line should be. Check that we have
      enough memory reserved for the line pointers; allocate more if
      needed.
    */
 
    line[lines] = &s[p];
    len[lines] = l;
    lines++;
 
    if (lines >= allocated)
    {
      allocated *= 2;
 
      line = (char **) realloc(line, sizeof(char *) * allocated);
      len = (int *) realloc(len, sizeof(int) * allocated);
 
      if (line == NULL || len == NULL)
	return 0;
    }
 
    /*
      Move on to the next line. This needs to be 1 less than the
      desired width or we will drop characters in the middle of
      really long words.
    */
    if (l == w)
      l--;
 
    p += l + 1;
  }
 
  /* Finally, relinquish memory we don't need */
  line = (char **) realloc(line, sizeof(char *) * lines);
  len = (int *) realloc(len, sizeof(int) * lines);
 
  *line_ret = line;
  *len_ret = len;
 
  return lines;
}
 
 
 
/*
  Test program for strwrap.
*/
int main()
{
  char test[700];
  char shit[100];
  char ** line;
  int * len;
  int lines;
  int i;
  int w;
 
  /* Prepare the string we wish to wrap */
  strcpy(test, "Hey this is a test ok testing some more let's see where this line breaks just a couple words more andareallylongwordthatshouldbreaksomewhereinhalf to see it's really working    and    now    let's see    how     it     works with   lots  of   whitespace and a couple of\nnewlines and also\n\ndouble newlines in different arrangements \n\n andanotherreallylongwordrightafteranewlinesowecanseeit'sworkingallright and now let's see how it aligns with the full line width\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa and line width + 1\n aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab yeah it seems pretty ok now the last line should be 10 wide\nok thx bye");
 
  /* The width of the destination "box" */
  w = 33;
 
  /* Call strwrap like this to wrap the string */
  lines = strwrap(test, w, &line, &len);
 
  /*
    Print the result. We'll print the length of each line we received
    and pad each line to w width.
  */
  printf("Got %d lines:\n\n", lines);
 
  for (i = 0; i < lines; i++)
  {
    strncpy(shit, line[i], len[i]);
    shit[len[i]] = '\0';
    printf("%4d |%-*s|\n", len[i], w, shit);
  }
 
  /* This is the only cleanup needed. */
  free(line);
  free(len);
 
  return 0;
}

https://www.rosettacode.org/wiki/Word_wrap#C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
 
/* nonsensical hyphens to make greedy wrapping method look bad */
const char *string = "In olden times when wishing still helped one, there lived a king "
	"whose daughters were all beautiful, but the youngest was so beautiful "
	"that the sun itself, which has seen so much, was astonished whenever "
	"it shone-in-her-face.  Close-by-the-king's castle lay a great dark "
	"forest, and under an old lime-tree in the forest was a well, and when "
	"the day was very warm, the king's child went out into the forest and "
	"sat down by the side of the cool-fountain, and when she was bored she "
	"took a golden ball, and threw it up on high and caught it, and this "
	"ball was her favorite plaything.";
 
/*	Each but the last of wrapped lines comes with some penalty as the square
	of the diff between line length and desired line length.  If the line
	is longer than desired length, the penalty is multiplied by 100.  This
	pretty much prohibits the wrapping routine from going over right margin.
	If is ok to exceed the margin just a little, something like 20 or 40 will
	do.
 
	Knuth uses a per-paragraph penalty for line-breaking in TeX, which is--
	unlike what I have here--probably bug-free.
*/
 
#define PENALTY_LONG	100
#define PENALTY_SHORT	1
 
typedef struct word_t {
	const char *s;
	int len;
} *word;
 
word make_word_list(const char *s, int *n)
{
	int max_n = 0;
	word words = 0;
 
	*n = 0;
	while (1) {
		while (*s && isspace(*s)) s++;
		if (!*s) break;
 
		if (*n >= max_n) {
			if (!(max_n *= 2)) max_n = 2;
			words = realloc(words, max_n * sizeof(*words));
		}
		words[*n].s = s;
		while (*s && !isspace(*s)) s++;
		words[*n].len = s - words[*n].s;
		(*n) ++;
	}
 
	return words;
}
 
int greedy_wrap(word words, int count, int cols, int *breaks)
{
	int score = 0, line, i, j, d;
 
	i = j = line = 0;
	while (1) {
		if (i == count) {
			breaks[j++] = i;
			break;
		}
 
		if (!line) {
			line = words[i++].len;
			continue;
		}
 
		if (line + words[i].len < cols) {
			line += words[i++].len + 1;
			continue;
		}
 
		breaks[j++] = i;
		if (i < count) {
			d = cols - line;
			if (d > 0)	score += PENALTY_SHORT * d * d;
			else if (d < 0)	score += PENALTY_LONG * d * d;
		}
 
		line = 0;
	}
	breaks[j++] = 0;
 
	return score;
}
 
/* tries to make right margin more even; pretty sure there's an off-by-one bug
	here somewhere */
int balanced_wrap(word words, int count, int cols, int *breaks)
{
	int *best = malloc(sizeof(int) * (count + 1));
 
	/* do a greedy wrap to have some baseline score to work with, else
	   we'll end up with O(2^N) behavior */
	int best_score = greedy_wrap(words, count, cols, breaks);
 
	void test_wrap(int line_no, int start, int score) {
		int line = 0, current_score = -1, d;
 
		while (start <= count) {
			if (line) line ++;
			line += words[start++].len;
			d = cols - line;
			if (start < count || d < 0) {
				if (d > 0)
					current_score = score + PENALTY_SHORT * d * d;
				else
					current_score = score + PENALTY_LONG * d * d;
			} else {
				current_score = score;
			}
 
			if (current_score >= best_score) {
				if (d <= 0) return;
				continue;
			}
 
			best[line_no] = start;
			test_wrap(line_no + 1, start, current_score);
		}
		if (current_score >= 0 && current_score < best_score) {
			best_score = current_score;
			memcpy(breaks, best, sizeof(int) * (line_no));
		}
	}
	test_wrap(0, 0, 0);
	free(best);
 
	return best_score;
}
 
void show_wrap(word list, int count, int *breaks)
{
	int i, j;
	for (i = j = 0; i < count && breaks[i]; i++) {
		while (j < breaks[i]) {
			printf("%.*s", list[j].len, list[j].s);
			if (j < breaks[i] - 1)
				putchar(' ');
			j++;
		}
		if (breaks[i]) putchar('\n');
	}
}
 
int main(void)
{
	int len, score, cols;
	word list = make_word_list(string, &len);
	int *breaks = malloc(sizeof(int) * (len + 1));
 
	cols = 80;
	score = greedy_wrap(list, len, cols, breaks);
	printf("\n== greedy wrap at %d (score %d) ==\n\n", cols, score);
	show_wrap(list, len, breaks);
 
	score = balanced_wrap(list, len, cols, breaks);
	printf("\n== balanced wrap at %d (score %d) ==\n\n", cols, score);
	show_wrap(list, len, breaks);
 
 
	cols = 32;
	score = greedy_wrap(list, len, cols, breaks);
	printf("\n== greedy wrap at %d (score %d) ==\n\n", cols, score);
	show_wrap(list, len, breaks);
 
	score = balanced_wrap(list, len, cols, breaks);
	printf("\n== balanced wrap at %d (score %d) ==\n\n", cols, score);
	show_wrap(list, len, breaks);
 
	return 0;
}

https://www.dreamincode.net/forums/topic/176365-word-wrap-in-c/

void print_wrapped(const char* buffer, size_t maxlength, int indent) {
  size_t count, buflen;
  const char *ptr, *endptr;

  count = 0;
  buflen = strlen(buffer);

  do {
    ptr = buffer + count;

    /* don't set endptr beyond the end of the buffer */
    if (ptr - buffer + maxlength <= buflen)
      endptr = ptr + maxlength;
    else
      endptr = buffer + buflen;

    /* back up EOL to a null terminator or space */
    while (*(endptr) && !isspace(*(endptr)) )
      endptr--;

    count += fwrite(ptr, 1, endptr - ptr, stdout);

    /* print a newline and an indent */
    printf("%-*s", indent, "\n");
  } while (*endptr);
}

